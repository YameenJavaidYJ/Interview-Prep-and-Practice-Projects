# JavaScript & React Interview Notes

This document summarizes key interview questions, explanations, and examples based on JavaScript, asynchronous behavior, and React.

═══════════════════════════════════════════════════════════════════════════════

## 1. Object Copying and Mutability

### Example 1: Independent Object Creation

    const dataNum1 = { a: 10, b: 20 };
    const dataNum2 = dataNum1;
    console.log(dataNum2);

    Output → { a: 30, b: 20 }

    Explanation: dataNum2 is direct assignment.

### Example 2: Shallow Copy with Spread Operator

    const dataNum3 = { a: 10, b: 20 };
    const dataNum4 = { ...dataNum3 };
    dataNum3.a = 30;
    console.log(dataNum4);

    Output → { a: 10, b: 20 }

    Explanation: The spread operator creates a shallow copy of the object.

    for DeepCopy use structuredClone

### Example 3: Nested Objects - Shallow Copy Limitation

    const dataNum5 = { a: 10, b: 20, c: { d: 40 } };
    const dataNum6 = { ...dataNum5 };
    dataNum5.c.d = 50;
    console.log(dataNum6);

    Output → { a: 10, b: 20, c: { d: 50 } }

    Explanation: Nested objects are NOT deeply cloned, so both objects share the same reference for 'c'.

═══════════════════════════════════════════════════════════════════════════════

## 2. Hoisting in JavaScript

### Basic Hoisting Example

    console.log(a);
    var a = 10;

    Output → undefined

    Explanation: Variable declarations (var) are hoisted but not initialized.

### Function Scope Hoisting

    var a = 10;
    function b() {
      console.log(a);
      var a = 20;
    }
    b();

    Output → undefined

    Explanation: The inner 'a' shadows the outer one, but due to hoisting, it is declared at the top with value 'undefined' until assignment.

═══════════════════════════════════════════════════════════════════════════════

## 3. Promises

A Promise in JavaScript has three states:

    1. Pending     → Initial state
    2. Fulfilled   → Operation completed successfully
    3. Rejected    → Operation failed

═══════════════════════════════════════════════════════════════════════════════

## 4. Async/Await vs Promises

    async function name() {
      return await Promise.resolve({ id: 2 });
    }

    console.log(name());

    Output → Promise { <pending> }

    Explanation: Async functions always return a Promise, even if you return a value.

### Key Differences:
    • Promises     → Chainable with .then() and .catch()
    • Async/Await  → Syntactic sugar to write asynchronous code in a synchronous style

═══════════════════════════════════════════════════════════════════════════════

## 5. Event Propagation

    • preventDefault()           → Prevents the default action of an element (e.g., stopping form submission)
    • stopPropagation()          → Stops further propagation of the event in the bubbling/capturing phase
    • stopImmediatePropagation() → Stops other listeners of the same event from executing

═══════════════════════════════════════════════════════════════════════════════

## 6. Event Loop Example

    console.log("Start");

    setTimeout(() => {
      console.log("Timeout 1");
    }, 0);

    Promise.resolve()
      .then(() => {
        console.log("Promise 1");
        return Promise.resolve();
      })
      .then(() => {
        console.log("Promise 2");
      });

    setTimeout(() => {
      console.log("Timeout 2");
    }, 0);

    console.log("End");

    Output → Start
             End
             Promise 1
             Promise 2
             Timeout 1
             Timeout 2

    Explanation: Microtasks (Promises) run before macrotasks (setTimeout) in the event loop.

═══════════════════════════════════════════════════════════════════════════════

## 7. Debouncing vs Throttling

    • Debouncing (Kind of Timeout) → Ensures a function is executed only after a certain time has passed since the last call
                   (useful for search input)
    
    • Throttling (Kind of Interval) → Ensures a function is executed at most once every given interval
                   (useful for scroll events)

═══════════════════════════════════════════════════════════════════════════════

## 8. Function Binding Issue

### Problem Example

    const obj = {
      a: 10,
      b: 20,
      c: () => {
        return b;
      }
    }

    console.log(obj.c());

    Error → ReferenceError: b is not defined

    Explanation: 'b' is not in scope.

### Solution

    const obj = {
      a: 10,
      b: 20,
      c() {
        return this.b;
      }
    }

═══════════════════════════════════════════════════════════════════════════════

## 9. Closure Issue with Loops

### Problem Example

    for (var i = 0; i <= 5; i++) {
      setTimeout(() => {
        console.log(i);
      }, i * 1000);
    }

    Output → 6 6 6 6 6 6

    Explanation: 'var' is function-scoped.

### Solution

    for (let i = 0; i <= 5; i++) {
      setTimeout(() => console.log(i), i * 1000);
    }

    Output → 0 1 2 3 4 5

═══════════════════════════════════════════════════════════════════════════════

## 10. React Concepts

### Virtual DOM vs Real DOM
    • Real DOM    → Directly updates the DOM (slower)
    • Virtual DOM → Updates a lightweight copy, React compares diffs and applies efficient updates

### useMemo vs useCallback
    • useMemo     → Memoizes a computed value
    • useCallback → Memoizes a function reference

### Controlled vs Uncontrolled Components
    • Controlled   → Value is controlled via React state (value + onChange)
    • Uncontrolled → Value managed by DOM itself (access via ref)

### Prop Drilling and Solutions 
    • Prop Drilling → Passing props through multiple layers unnecessarily
    • Solutions     → Context API, Redux, Zustand, Recoil, or useContext hook

### useReducer vs useState
    • useState    → Simple state management
    • useReducer  → Good for complex state logic with multiple transitions

═══════════════════════════════════════════════════════════════════════════════

## 11. Coding Problem: Memoize Function

### Problem Statement
Create a memorize function that caches results of a given function. 
If the function's arguments don't change, it returns the cached result. 
If arguments change, it calls the actual function and returns the new result.

### Example Usage

    function slowAdd(a, b) {
      console.log("Calling slowAdd...");
      return a + b;
    }

    const memorizedAdd = memorize(slowAdd);

    // First call: calculates and caches result
    console.log(memorizedAdd(2, 3)); // Output: "Calling slowAdd...", 5

    // Second call with same args: returns cached result, no log
    console.log(memorizedAdd(2, 3)); // Output: 5

    // Call with different args: calls original function again
    console.log(memorizedAdd(4, 3)); // Output: "Calling slowAdd...", 7

    // Again with (4, 3): returns from cache
    console.log(memorizedAdd(4, 3)); // Output: 7


    const memorize (func) = {
        
        return func;
    }

    ...args is called rest paramter in form of function
    Rest parameters in JavaScript provide a way for a 
    function to accept an indefinite number of arguments 
    as an array. 
    They are indicated by three dots (...) followed by the 
    name of the parameter, and this parameter must always be 
    the last formal parameter in the function definition.
    ...args convert what ever is passed function in in array
    (1,2,3) will be converted to [1,2,3] and stored in args

### Solution

    function memorize(fn) {
        const mapStore = new Map();
        
        return (...args) => {
            const key = JSON.stringify(args);

            if (mapStore.has(key)) {
                return mapStore.get(key);
            }

            const result = fn.apply(this, args);
            cache.set(key, result);
            return result;
        };
    }

    const test = {
        a: 3,
        b: 5
    }

    // Example usage:
    function slowAdd(a, b) {
      console.log("Calling slowAdd...");
      return a + b;
    }

    const memorizedAdd = memorize(slowAdd);

    console.log(memorizedAdd(2, 3)); // "Calling slowAdd...", 5

    --------------------------------------

    function memoize(func) {
        const cache = new Map();

        return function(...args) {  // <-- rest parameter collects arguments into an array
            const key = JSON.stringify(args ); 

            if (cache.has(key)) {
            return cache.get(key);
            }

            const result = func(...args);  // <-- spreading turns the array back into separate arguments
            cache.set(key, result);
            return result;
        };
    }

    --------------------------------------

    const memorizedAdd = memorize(slowAdd);

    console.log(memorizedAdd(2, 3)); // "Calling slowAdd...", 5
    console.log(memorizedAdd(2, 3)); // 5 (cached)
    console.log(memorizedAdd(4, 3)); // "Calling slowAdd...", 7
    console.log(memorizedAdd(4, 3)); // 7 (cached)

### Key Features
    ✓ Handles multiple arguments
    ✓ Efficient caching
    ✓ Works for primitives and serializable objects

═══════════════════════════════════════════════════════════════════════════════

## Summary

These are the most common JavaScript & React interview questions. Key areas to focus on:

    • JavaScript Fundamentals    → Scope, closures, hoisting
    • Asynchronous Programming   → Event loop & async behavior
    • React Hooks               → useState, useReducer, useMemo, useCallback
    • Performance Optimization  → Memoization, debouncing, throttling
    • Problem Solving           → Practical coding challenges


const person = {
    fullName: function(city, country) {
        return this.firstName + " " + this.lastName + "," + city + "," + country;
    }
}

const person1 = {
    firstName:"John",
    lastName: "Doe"
}

person.fullName.call(person1, "Oslo", "Norway");

person.fullName.apply(person1, ["Oslo", "Norway"]);

-------------------------------------------------------

The call() method takes arguments separately.

The apply() method takes arguments as an array.

UnderStand this, apply, call

