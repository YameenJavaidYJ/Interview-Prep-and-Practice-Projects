Scaykar Interview Questions - Comprehensive Answers & Context Questions

Context Questions:

3. "What are dead tuples and how do they accumulate?"

Answer:
Dead tuples are old versions of rows that are no longer visible to any transaction due to PostgreSQL's MVCC (Multi-Version Concurrency Control) system. They accumulate when:
- Rows are updated (old version becomes dead tuple)
- Rows are deleted (entire row becomes dead tuple)
- Transactions that created these versions complete

Dead tuples take up space but are not immediately removed. They are cleaned up by the VACUUM process, which can be automatic or manual.

---

Context Questions:

1. "What types of errors can error boundaries catch vs what they can't?"

Answer:
Error boundaries CAN catch:
- Errors during rendering
- Errors in lifecycle methods
- Errors in constructors of class components
- Errors in the whole tree below them

Error boundaries CANNOT catch:
- Errors inside event handlers
- Errors in asynchronous code (setTimeout, promises)
- Errors during server-side rendering
- Errors thrown in the error boundary itself

---

Context Questions:

1. "How do you test error boundaries?"

Answer:
- Use React Testing Library or Enzyme
- Simulate errors by throwing exceptions in child components
- Test both error state and recovery scenarios
- Mock console.error to avoid noise in tests
- Test error reporting integration
- Verify fallback UI is rendered correctly

---

Context Questions:

5. "When would you use multiple error boundaries in a single app?"

Answer:
- Different sections of the app (header, sidebar, main content)
- Different feature areas (user profile, dashboard, settings)
- Different levels of error handling (critical vs non-critical)
- Different error recovery strategies
- Isolate errors to prevent entire app crashes
- Provide more specific error messages to users

---

Context Questions:

1. "What are the best practices for API design and versioning?"

Answer:
- Use semantic versioning (v1, v2, v3)
- Include version in URL path (/api/v1/users) or headers
- Maintain backward compatibility when possible
- Deprecate old versions with proper notice
- Use consistent naming conventions
- Document API changes and migration guides
- Implement proper HTTP status codes
- Use content negotiation for different formats

---

Context Questions:

1. "What are the trade-offs between different caching strategies (Redis vs Memcached)?"

Answer:
- Redis: Rich data types, persistence, clustering, more memory usage
- Memcached: Simple key-value, higher performance, less memory usage
- Redis: Better for complex data structures, pub/sub, transactions
- Memcached: Better for simple caching, higher throughput
- Use Redis: When you need persistence, complex data types, clustering
- Use Memcached: When you need maximum performance for simple caching