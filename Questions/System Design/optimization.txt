8. How to Optimize Express App Performance

Answer:

Express.js Performance Optimization:

1. Middleware Optimization:

    - Order middleware efficiently
    - Use compression middleware
    - Implement proper error handling

2. Caching:

    - Redis for session storage
    - Response caching
    - Static file caching

3. Database Optimization:

    - Connection pooling
    - Query optimization
    - Database indexing

4. Code Optimization:

    - Avoid blocking operations
    - Use async/await properly
    - Implement proper error handling

5. Infrastructure:

    - Load balancing
    - CDN for static assets
    - Process management (PM2)

6. Monitoring:
    - Performance monitoring
    - Memory leak detection
    - Request/response logging

---------------------------------------------------------------

7. How to Optimize React App Performance

Answer:

Performance Optimization Techniques:

1. Code Splitting:

    - Lazy loading components
    - Route-based code splitting
    - Dynamic imports

2. Memoization:

    - React.memo for components
    - useMemo for expensive calculations
    - useCallback for functions

3. Bundle Optimization:

    - Tree shaking
    - Bundle analysis
    - Webpack optimization

4. Rendering Optimization:

    - Avoid unnecessary re-renders
    - Optimize state updates
    - Use proper dependency arrays

5. Asset Optimization:

    - Image optimization
    - CDN usage
    - Compression

6. React-Specific:
    - Virtual scrolling for large lists
    - Suspense for better loading states
    - Error boundaries

---------------------------------------------------------------

6. How to Optimize DB Queries

Answer:

Query Optimization Techniques:

1. Indexing:

    - Create appropriate indexes on frequently queried columns
    - Composite indexes for multi-column queries
    - Avoid over-indexing (slows writes)

2. Query Structure:

    - Use EXPLAIN/EXPLAIN ANALYZE to understand execution plans
    - Avoid SELECT * - select only needed columns
    - Use LIMIT for large result sets
    - Optimize JOINs and subqueries

3. Database Design:

    - Normalize appropriately (avoid over-normalization)
    - Use appropriate data types
    - Consider denormalization for read-heavy workloads

4. Caching:

    - Application-level caching (Redis, Memcached)
    - Query result caching
    - Database query cache

5. Connection Management:
    - Connection pooling
    - Proper connection timeouts
    - Avoid N+1 queries

---

Additional Questions:

Q: How do you measure and monitor application performance?

A:
- Application Performance Monitoring (APM) tools: New Relic, Datadog, AppDynamics
- Metrics: Response time, throughput, error rate, resource utilization
- Logging: Structured logging with correlation IDs
- Profiling: CPU, memory, I/O profiling tools
- Real User Monitoring (RUM): Client-side performance metrics
- Synthetic monitoring: Automated testing of critical paths

Q: What are the common performance bottlenecks in web applications?

A:
- Database queries: N+1 queries, missing indexes, inefficient joins
- Network latency: Slow API calls, large payloads, unnecessary requests
- Memory leaks: Unreleased objects, event listeners, closures
- CPU-intensive operations: Synchronous processing, blocking I/O
- Caching issues: Cache misses, stale data, inefficient cache strategies
- Resource contention: Database connections, file handles, network connections

Q: How do you implement caching strategies effectively?

A:
- Cache-aside: Application manages cache, lazy loading
- Write-through: Update cache and database simultaneously
- Write-behind: Update cache first, database later
- Cache invalidation: TTL, event-driven, version-based
- Cache warming: Pre-populate cache with frequently accessed data
- Multi-level caching: Browser, CDN, application, database levels

Q: What are the best practices for database performance tuning?

A:
- Indexing: Create appropriate indexes, avoid over-indexing
- Query optimization: Use EXPLAIN, avoid SELECT *, optimize JOINs
- Connection pooling: Reuse database connections
- Partitioning: Split large tables by range, hash, or list
- Denormalization: Trade storage for query performance
- Monitoring: Track slow queries, resource usage, connection counts

---

Additional Questions:

Q: How do you identify slow queries in a production database?

A:
- Database monitoring tools: pg_stat_statements, MySQL slow query log
- APM tools: New Relic, Datadog database monitoring
- Query profiling: EXPLAIN ANALYZE, execution plans
- Performance schema: MySQL performance_schema tables
- Custom logging: Log queries with execution time
- Regular analysis: Review slow query reports

Q: What's the difference between clustered and non-clustered indexes?

A:
- Clustered: Data physically ordered by index key, only one per table
- Non-clustered: Separate structure, multiple per table, points to data
- Clustered: Faster for range queries, slower for inserts/updates
- Non-clustered: Slower for range queries, faster for inserts/updates
- Clustered: Primary key is usually clustered
- Non-clustered: Secondary indexes, foreign keys

Q: How do you optimize queries with multiple JOINs?

A:
- Proper indexing: Index join columns and WHERE clauses
- Query order: Start with most selective table
- Use EXPLAIN: Analyze execution plan and cost
- Avoid cartesian products: Use proper JOIN conditions
- Consider denormalization: Reduce JOINs for frequently accessed data
- Use covering indexes: Include all needed columns in index

Q: What are query hints and when should you use them?

A:
- Query hints: Directives to query optimizer about execution strategy
- Types: Index hints, join hints, query plan hints
- Use sparingly: Only when optimizer makes wrong decisions
- Examples: USE INDEX, FORCE INDEX, IGNORE INDEX
- Monitor performance: Ensure hints actually improve performance
- Document usage: Explain why hints are necessary

Q: How do you handle query optimization in a microservices architecture?

A:
- Service-specific optimization: Each service optimizes its own queries
- Cross-service queries: Use API composition, avoid distributed JOINs
- Caching: Cache frequently accessed data across services
- Data denormalization: Duplicate data to avoid cross-service queries
- Event-driven updates: Use events to keep denormalized data in sync
- Monitoring: Track query performance across all services

---

Additional Questions:

Q: How do you implement connection pooling in Express.js?

A:
- Use connection pool libraries: pg-pool, mysql2, mongodb driver
- Configure pool size: Based on concurrent connections needed
- Set timeouts: Connection timeout, idle timeout, query timeout
- Monitor pool: Track active/idle connections, queue length
- Handle errors: Connection failures, pool exhaustion
- Example: const pool = new Pool({ max: 20, idleTimeoutMillis: 30000 })

Q: What's the difference between clustering and load balancing?

A:
- Clustering: Multiple processes on same machine, share CPU cores
- Load balancing: Distribute requests across multiple machines/servers
- Clustering: Use all CPU cores, single machine, process-level
- Load balancing: Multiple machines, network-level, geographic distribution
- Tools: PM2 for clustering, Nginx/HAProxy for load balancing
- Use both: Cluster within each server, load balance across servers

Q: How do you handle memory leaks in Node.js applications?

A:
- Monitor memory usage: process.memoryUsage(), heap snapshots
- Identify leaks: Chrome DevTools, heap profiler, allocation timeline
- Common causes: Event listeners, timers, closures, circular references
- Prevention: Remove event listeners, clear timers, avoid global variables
- Tools: clinic.js, 0x, heapdump for profiling
- Regular monitoring: Set up alerts for memory usage

Q: What are the best practices for error handling in Express?

A:
- Error middleware: Centralized error handling with (err, req, res, next)
- Try-catch: Wrap async operations in try-catch blocks
- Error types: Distinguish between operational and programming errors
- Logging: Use structured logging with correlation IDs
- User-friendly messages: Don't expose internal errors to users
- Monitoring: Track error rates and patterns

Q: How do you implement rate limiting in Express applications?

A:
- Middleware: express-rate-limit, express-slow-down
- Strategies: Fixed window, sliding window, token bucket
- Storage: Memory, Redis, database for distributed systems
- Headers: X-RateLimit-* headers for client information
- Different limits: Per IP, per user, per endpoint
- Bypass: Whitelist certain IPs or users

Q: How do you implement sticky sessions in a load-balanced Express app?

A:
- Session affinity: Route same user to same server
- Load balancer: Configure sticky sessions (session persistence)
- Session storage: Use Redis or database for shared sessions
- Cookie configuration: Set appropriate session cookie options
- Fallback: Handle server failures gracefully
- Considerations: Server maintenance, scaling challenges

Q: How do you handle stateful data in a stateless Express app?

A:
- External storage: Redis, database, or external session store
- JWT tokens: Stateless authentication with signed tokens
- Client-side storage: Store non-sensitive data in cookies/localStorage
- Database: Store user state in database with user ID
- Cache: Use Redis for temporary state storage
- Design: Keep application stateless, externalize state

Q: What are the best practices for monitoring Express applications?

A:
- APM tools: New Relic, Datadog, AppDynamics
- Metrics: Response time, throughput, error rate, memory usage
- Logging: Structured logging with correlation IDs
- Health checks: /health endpoint for load balancer
- Alerts: Set up alerts for critical metrics
- Dashboards: Visualize application performance and health
