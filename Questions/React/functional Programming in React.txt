Functional Programming in React & Redux
--------

-> Overview
Functional programming principles are fundamental to modern React development and are deeply integrated into Redux architecture. Understanding these principles is crucial for writing maintainable, predictable, and testable code.

--------

Core Functional Programming Principles
--------

-> 1. Pure Functions
    - Same input â†’ same output, no side effects
    - Predictable, testable, debuggable
    - No external dependencies or mutations

-> 2. Immutability
    - Create new objects instead of modifying existing ones
    - Prevents unexpected bugs
    - Enables time-travel debugging

-> 3. Higher-Order Functions
    - Functions that take/return other functions
    - Enables composition and reusability
    - Foundation for middleware and hooks

-> 4. Function Composition
    - Build complex functionality from simple functions
    - Promotes modularity and reusability
    - Chain operations together

-> 5. Declarative Programming
    - Focus on "what" not "how"
    - More readable and maintainable
    - Describes desired outcome

--------

Redux Implementation of FP Principles
--------

-> 1. Pure Reducers
    - (state, action) => newState
    - No mutations, predictable state updates
    - Same input always produces same output

-> 2. Immutable State
    - Always return new state objects
    - Enables Redux DevTools time-travel
    - Prevents accidental mutations

-> 3. Action Creators
    - Functions returning action objects
    - Composable and reusable
    - Pure functions for state changes

-> 4. Middleware Composition
    - Higher-order functions for side effects
    - Chainable middleware pipeline
    - Functional approach to side effects

-> 5. Declarative State Management
    - Describe state changes, Redux handles implementation
    - Predictable state flow
    - Clear separation of concerns

--------

Interview Questions
--------

-> Q: How do you handle side effects in Redux while maintaining functional programming principles?

A:
    - Redux Thunk: Handle async operations in action creators
    - Redux Saga: Use generators for complex side effects
    - Redux Observable: Use RxJS for reactive programming
    - Middleware: Create custom middleware for side effects
    - Keep reducers pure: Move side effects to action creators/middleware
    - Use selectors: Pure functions for state derivation

-> Q: What's the difference between Redux and other state management libraries in terms of FP principles?

A:
    - Redux: Pure reducers, immutable state, functional composition
    - MobX: Mutable state, object-oriented, automatic tracking
    - Zustand: Minimal API, mutable updates, less FP-focused
    - Context API: React-specific, less predictable updates
    - Redux: More functional, better for complex state logic
    - Others: More imperative, easier to use but less predictable

-> Q: How do you implement immutable updates in Redux reducers?

A:
    - Object spread: {...state, newProperty: value}
    - Array methods: [...array, newItem] or array.filter()
    - Nested updates: {...state, user: {...state.user, name: newName}}
    - Immer library: Write mutable code, get immutable updates
    - Structural sharing: Only change what's necessary
    - Avoid: Direct mutations, push(), splice(), direct property assignment

-> Q: What are the benefits of using pure functions in Redux?

A:
    - Predictability: Same input always produces same output
    - Testability: Easy to test without mocking
    - Debugging: Time-travel debugging, replay actions
    - Performance: Can memoize and optimize
    - Reasoning: Easier to understand and maintain
    - Parallelization: Can run in parallel safely

-> Q: How does Redux middleware follow functional programming principles?

A:
    - Higher-order functions: Middleware is a function that returns a function
    - Function composition: Multiple middleware compose together
    - Pure functions: Each middleware should be pure when possible
    - Immutability: Don't mutate the action or state
    - Side effects: Handle side effects in middleware, not reducers
    - Currying: Middleware uses curried functions for configuration
