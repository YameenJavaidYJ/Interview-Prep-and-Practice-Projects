üìí setTimeout in Loops ‚Äî var vs let vs Staggered Delays
1Ô∏è‚É£ Using var (function-scoped)
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}

Behavior

var is function-scoped, so the same i is shared across all callbacks.

The loop finishes first (i = 3).

After ~100ms, all 3 timers expire and log the same value.

Output (after ~100ms, all together)
3
3
3

2Ô∏è‚É£ Using let (block-scoped)
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}

Behavior

let is block-scoped, so each loop iteration gets its own copy of i.

Timers are still all scheduled with 100ms delay.

After ~100ms, all timers expire at once, but each logs its own i.

Output (after ~100ms, all together)
0
1
2

3Ô∏è‚É£ Using let with staggered delays
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), i * 100);
}

Behavior

Still block-scoped (let).

But each timer‚Äôs delay depends on i:

i = 0 ‚Üí 0ms

i = 1 ‚Üí 100ms

i = 2 ‚Üí 200ms

So logs happen sequentially over time.

Output
0   // immediately
1   // after 100ms
2   // after 200ms

‚úÖ Summary Table
Case	Scope of i	Delay setting	Output	When logs happen
var	Function-wide	All 100ms	3, 3, 3	Together (~100ms later)
let	Block-scoped	All 100ms	0, 1, 2	Together (~100ms later)
let staggered	Block-scoped	i * 100 (0,100,200)	0, 1, 2	Sequential (0/100/200ms)