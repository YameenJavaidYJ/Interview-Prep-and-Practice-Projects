================================================================================
                                  INTERFACES
================================================================================

1. Declaration Merging
-----------------
   → Interfaces can be declared multiple times with the same name, and TypeScript 
     will automatically merge their definitions. This is useful for extending 
     existing types or libraries.

   Example:
   ```typescript
   interface User {
       name: string;
   }
   
   interface User {
       age: number;
   }
   
   // Merged interface: User now has both name and age
   const user: User = {
       name: "John",
       age: 25
   };
   ```

2. Primarily for Object Shapes
-----------------
   → Interfaces are ideal for defining the structure of objects, specifying 
     properties and methods.

   Example:
   ```typescript
   interface Product {
       id: number;
       name: string;
       price: number;
       isAvailable: boolean;
       getDescription(): string;
   }
   
   const laptop: Product = {
       id: 1,
       name: "MacBook Pro",
       price: 2499,
       isAvailable: true,
       getDescription() {
           return `${this.name} - $${this.price}`;
       }
   };
   ```

3. Implementation with Classes
-----------------
   → Classes can implement interfaces, ensuring they adhere to a specific contract.

   Example:
   ```typescript
   interface Drawable {
       draw(): void;
       color: string;
   }
   
   class Circle implements Drawable {
       color: string;
       radius: number;
       
       constructor(color: string, radius: number) {
           this.color = color;
           this.radius = radius;
       }
       
       draw(): void {
           console.log(`Drawing a ${this.color} circle with radius ${this.radius}`);
       }
   }
   ```

4. Extending other Interfaces
-----------------
   → Interfaces can extend other interfaces to inherit their properties and methods.

   Example:
   ```typescript
   interface Animal {
       name: string;
       age: number;
   }
   
   interface Dog extends Animal {
       breed: string;
       bark(): void;
   }
   
   const myDog: Dog = {
       name: "Buddy",
       age: 3,
       breed: "Golden Retriever",
       bark() {
           console.log("Woof!");
       }
   };
   ```

================================================================================
                                TYPE ALIASES
================================================================================

1. More Versatile
-----------------
   → Type aliases can define not only object shapes but also primitive types, 
     union types, intersection types, mapped types, and conditional types.

   Examples:
   ```typescript
   // Primitive type alias
   type ID = string | number;
   
   // Union type
   type Status = "pending" | "approved" | "rejected";
   
   // Object shape
   type User = {
       id: ID;
       name: string;
       status: Status;
   };
   
   // Function type
   type EventHandler = (event: Event) => void;
   
   // Mapped type
   type Partial<T> = {
       [P in keyof T]?: T[P];
   };
   
   // Conditional type
   type ApiResponse<T> = T extends string ? string : T;
   ```

2. No Declaration Merging
-----------------
   → A type alias cannot be declared multiple times; attempting to do so will 
     result in an error.

   Example:
   ```typescript
   type User = {
       name: string;
   };
   
   // ❌ Error: Duplicate identifier 'User'
   // type User = {
   //     age: number;
   // };
   
   // ✅ Instead, use intersection types
   type UserWithAge = User & {
       age: number;
   };
   ```

3. Extending with Intersection Types
-----------------
   → While interfaces use extends, type aliases achieve similar extension 
     through intersection types.

   Example:
   ```typescript
   type BaseEntity = {
       id: string;
       createdAt: Date;
   };
   
   type User = BaseEntity & {
       name: string;
       email: string;
   };
   
   type Product = BaseEntity & {
       name: string;
       price: number;
   };
   
   const user: User = {
       id: "user-123",
       createdAt: new Date(),
       name: "Alice",
       email: "alice@example.com"
   };
   ```

4. Defining Function Signatures
-----------------
   → Type aliases are often preferred for defining function signatures.

   Example:
   ```typescript
   // Function type aliases
   type MathOperation = (a: number, b: number) => number;
   type AsyncOperation<T> = (input: T) => Promise<T>;
   type EventCallback<T> = (data: T) => void;
   
   // Usage
   const add: MathOperation = (a, b) => a + b;
   const multiply: MathOperation = (a, b) => a * b;
   
   const processData: AsyncOperation<string> = async (input) => {
       // Some async processing
       return input.toUpperCase();
   };
   
   const onUserLogin: EventCallback<User> = (user) => {
       console.log(`User ${user.name} logged in`);
   };
   ```

================================================================================
